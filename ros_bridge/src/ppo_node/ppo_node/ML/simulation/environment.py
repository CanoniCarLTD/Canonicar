import time
import random
import numpy as np
import pygame
from simulation.connection import carla
from simulation.sensors import CameraSensor, CameraSensorEnv, CollisionSensor
from simulation.settings import *


class CarlaEnvironment:
    def __init__(self, track, checkpoint_frequency=100) -> None:

        self.current_waypoint_index = 0
        self.checkpoint_waypoint_index = 0
        self.fresh_start = True
        self.checkpoint_frequency = checkpoint_frequency
        self.route_waypoints = None
        self.track = track

    # ----------------------------------------------------------------
    # Step method is used for implementing actions taken by our agent|
    # ----------------------------------------------------------------

    # A step function is used for taking inputs generated by neural net.
    def step(self, action_idx):
        """return [image_obs, navigation_obs], reward, done, distance_covered"""
        try:
            self.timesteps += 1
            self.fresh_start = False

            # Velocity of the vehicle
            velocity = self.vehicle.get_velocity()
            self.velocity = np.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2) * 3.6

            # Action from action space for contolling the vehicle with a discrete action
            """ DELETE DISCRETE STUFF AND TAKE CARE OF CONTINUOUS ACTIONS (ETAI) """
            if self.continous_action_space:
                steer = float(action_idx[0])
                steer = max(min(steer, 1.0), -1.0)
                throttle = float((action_idx[1] + 1.0) / 2)
                throttle = max(min(throttle, 1.0), 0.0)
                brake = float((action_idx[2] + 1.0) / 2)
                # Here we need to publish the action to the vehicle with ros
                self.previous_steer = steer
                self.throttle = throttle

            self.collision_history = self.collision_obj.collision_data

            # Rotation of the vehicle in correlation to the map/lane
            self.rotation = self.vehicle.get_transform().rotation.yaw

            # Location of the car
            self.location = self.vehicle.get_location()

            # Keep track of closest waypoint on the route
            waypoint_index = self.current_waypoint_index
            for _ in range(len(self.route_waypoints)):
                # Check if we passed the next waypoint along the route
                next_waypoint_index = waypoint_index + 1
                wp = self.route_waypoints[
                    next_waypoint_index % len(self.route_waypoints)
                ]
                dot = np.dot(
                    self.vector(wp.transform.get_forward_vector())[:2],
                    self.vector(self.location - wp.transform.location)[:2],
                )
                if dot > 0.0:
                    waypoint_index += 1
                else:
                    break

            self.current_waypoint_index = waypoint_index
            # Calculate deviation from center of the lane
            self.current_waypoint = self.route_waypoints[
                self.current_waypoint_index % len(self.route_waypoints)
            ]
            self.next_waypoint = self.route_waypoints[
                (self.current_waypoint_index + 1) % len(self.route_waypoints)
            ]
            self.distance_from_center = self.distance_to_line(
                self.vector(self.current_waypoint.transform.location),
                self.vector(self.next_waypoint.transform.location),
                self.vector(self.location),
            )
            self.center_lane_deviation += self.distance_from_center

            # Get angle difference between closest waypoint and vehicle forward vector
            fwd = self.vector(self.vehicle.get_velocity())
            wp_fwd = self.vector(
                self.current_waypoint.transform.rotation.get_forward_vector()
            )
            self.angle = self.angle_diff(fwd, wp_fwd)

            # Update checkpoint for training
            if not self.fresh_start:
                if self.checkpoint_frequency is not None:
                    self.checkpoint_waypoint_index = (
                        self.current_waypoint_index // self.checkpoint_frequency
                    ) * self.checkpoint_frequency

            # Create a new function for rewards.
            done = False
            reward = 0

            if len(self.collision_history) != 0:
                done = True
                reward = -10

            elif self.episode_start_time + 10 < time.time() and self.velocity < 1.0:
                reward = -10
                done = True

            if not done:
                pass

            if self.timesteps >= 7500:
                done = True
            elif self.current_waypoint_index >= len(self.route_waypoints) - 2:
                done = True
                self.fresh_start = True
                if self.checkpoint_frequency is not None:
                    if self.checkpoint_frequency < self.total_distance // 2:
                        self.checkpoint_frequency += 2
                    else:
                        self.checkpoint_frequency = None
                        self.checkpoint_waypoint_index = 0

            while len(self.camera_obj.front_camera) == 0:
                time.sleep(0.0001)

            return (
                [self.image_obs, self.navigation_obs],
                reward,
                done,
                self.distance_covered,
            )

        except:
            return -1
